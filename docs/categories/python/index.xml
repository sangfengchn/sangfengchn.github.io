<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Sang Feng | 桑峰</title>
    <link>/categories/python/</link>
    <description>Recent content in Python on Sang Feng | 桑峰</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 22 Aug 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python作图-Heatmap</title>
      <link>/post/2021/08/22/blog/</link>
      <pubDate>Sun, 22 Aug 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/08/22/blog/</guid>
      <description>&lt;p&gt;本文用于记录笔者在使用seaborn绘制heatmap中遇到的一些问题和解决方法。&lt;/p&gt;&#xA;&lt;p&gt;完整的代码如下所示：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np&#xA;import pandas as pd&#xA;import seaborn as sns&#xA;import matplotlib.pyplot as plt&#xA;import matplotlib.font_manager as fm&#xA;import matplotlib.ticker as ticker&#xA;sns.set_theme(style=&amp;quot;white&amp;quot;)&#xA;&#xA;mat = np.random.rand(68*68)&#xA;mat = mat.reshape((68, 68))&#xA;labels = pd.DataFrame({&#39;Name&#39;: range(1, 69)})&#xA;&#xA;&#xA;cmap = sns.color_palette(&#39;flare&#39;, as_cmap=True)&#xA;&#xA;font = fm.FontProperties(fname=&#39;Resource/font/calibri.ttf&#39;)&#xA;&#xA;p = sns.heatmap(&#xA;    mat,&#xA;    mask=(mat==0),&#xA;    cmap=cmap,&#xA;    square=True,&#xA;    xticklabels=True,&#xA;    yticklabels=True,&#xA;    center=0.75,&#xA;    vmin=0.5)&#xA;&#xA;ax = p.figure.axes[0]&#xA;ax.axvline(34, color=&#39;k&#39;, alpha=0.8, linestyle=&#39;-&#39;, linewidth=0.8)&#xA;ax.axhline(34, color=&#39;k&#39;, alpha=0.8, linestyle=&#39;-&#39;, linewidth=0.8)&#xA;ax.set_title(&#39;Title of Heatmap&#39;, fontproperties=font, fontsize=14)&#xA;ax.set_xticklabels(labels[&#39;Name&#39;], fontproperties=font, fontsize=4)&#xA;ax.set_yticklabels(labels[&#39;Name&#39;], fontproperties=font, fontsize=4)&#xA;&#xA;barax = p.figure.axes[1]&#xA;barax.set_ylabel(&#39;Mean Value&#39;, fontproperties=font, fontsize=12)&#xA;barticks = barax.get_yticks()&#xA;tickformat = &#39;{:.1f}&#39;&#xA;barax.yaxis.set_major_locator(ticker.FixedLocator(barticks))&#xA;barax.set_yticklabels([tickformat.format(x) for x in barticks], fontproperties=font, fontsize=10)&#xA;barax.tick_params(direction=&#39;in&#39;, width=0)&#xA;&#xA;plt.savefig(&#39;demo.png&#39;, bbox_inches=&#39;tight&#39;, dpi=500)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;center&gt;&#xA;    &lt;img style=&#34;width:50%;&#34; &#xA;    src=&#34;./img/fig_1.png&#34;&gt;&#xA;    &lt;br&gt;&#xA;    &lt;div style=&#34;color:orange; border-bottom: 1px solid #d9d9d9;&#xA;    display: inline-block;&#xA;    color: #999;&#xA;    padding: 2px;&#34;&gt;图1. 示例结果&lt;/div&gt;&#xA;&lt;/center&gt;&#xA;&lt;h1 id=&#34;解释&#34;&gt;解释&lt;/h1&gt;&#xA;&lt;p&gt;导入相关包：&lt;/p&gt;</description>
    </item>
    <item>
      <title>远程Jupyter Notebook设置</title>
      <link>/post/2021/06/24/blog/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/06/24/blog/</guid>
      <description>&lt;p&gt;通过Jupyter可以使用远端服务器的计算资源，以下是设置步骤。&lt;/p&gt;&#xA;&lt;h1 id=&#34;安装jupyter&#34;&gt;安装Jupyter&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## pip 安装&#xA;pip install notebook&#xA;&#xA;## conda安装&#xA;conda install -c conda-forge notebook&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;服务器端设置&#34;&gt;服务器端设置&lt;/h1&gt;&#xA;&lt;h3 id=&#34;生成密码密文&#34;&gt;生成密码密文：&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;jupyter notebook password&#xA;Enter password:  &#xA;Verify password: &#xA;&amp;gt; [NotebookPasswordApp] Wrote hashed password to /home/you/.jupyter/jupyter_notebook_config.json&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;密文保存在/home/you/.jupyter/jupyter_notebook_config.json文件中。&lt;/p&gt;&#xA;&lt;h3 id=&#34;修改配置文件&#34;&gt;修改配置文件&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## 打开前面生成的配置文件&#xA;vim ~/.jupyter/jupyter_notebook_config.py&#xA;## 修改配置内容&#xA;c.NotebookApp.ip=&#39;*&#39;&#xA;## 修改成将之前生成的密文&#xA;c.NotebookApp.password = u&#39;xxx&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;启动jupyter&#34;&gt;启动Jupyter&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;jupyter notebook --no-browser --port=8889&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;本地设置&#34;&gt;本地设置&lt;/h1&gt;&#xA;&lt;p&gt;打开本地终端，输入以下命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;ssh -N -f -L localhost:8836:localhost:8889 xxx@ip&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;之后打开浏览器，在地址栏中输入http://localhost:8836即可。&lt;/p&gt;&#xA;&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;&#xA;&lt;p&gt;[1] &lt;a href=&#34;https://blog.csdn.net/weixin_40641725/article/details/114636779&#34;&gt;https://blog.csdn.net/weixin_40641725/article/details/114636779&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;[2] &lt;a href=&#34;https://zhuanlan.zhihu.com/p/166425946&#34;&gt;https://zhuanlan.zhihu.com/p/166425946&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python函数参数中的“*”</title>
      <link>/post/2021/06/17/blog/</link>
      <pubDate>Thu, 17 Jun 2021 00:00:00 +0000</pubDate>
      <guid>/post/2021/06/17/blog/</guid>
      <description>&lt;p&gt;Python中，*除了可用于乘法和乘方运算外，还可以把它放在函数形式参数的前面，用来传递多个参数或进行参数的拆解。下面简单介绍后者的用法。&lt;/p&gt;&#xA;&lt;h1 id=&#34;传递多参数&#34;&gt;传递多参数&lt;/h1&gt;&#xA;&lt;h3 id=&#34;demo1&#34;&gt;示例1&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(*x):&#xA;    print(x)&#xA;&#xA;f(1, 2, 3, 4)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;输出：(1, 2, 3, 4)&lt;/p&gt;&#xA;&lt;p&gt;可见，虽然在定义函数**f()**时，只用了一个形式参数x，但是由于*的存在，再调用该函数时，即便是传递多个参数，也会把多个参数当成一个变量x（这里当作元组处理）来处理。&lt;/p&gt;&#xA;&lt;h3 id=&#34;demo2&#34;&gt;示例2&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(**x):&#xA;    print(x)&#xA;    &#xA;f(a=1, b=2, c=3, d=4)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;输出：{&amp;lsquo;a&amp;rsquo;: 1, &amp;lsquo;b&amp;rsquo;: 2, &amp;lsquo;c&amp;rsquo;: 3, &amp;rsquo;d&amp;rsquo;: 4}&lt;/p&gt;&#xA;&lt;p&gt;**也可以接收多个参数，但是跟*不同的是，**接收带有key的参数，并且将多个key-value形式的参数转换成为一个字典。&lt;/p&gt;&#xA;&lt;h1 id=&#34;demo3&#34;&gt;拆分参数&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(*x):&#xA;    print(x)&#xA;&#xA;# Test 1&#xA;f(1, 2)&#xA;# Test 2&#xA;f((1, 2))&#xA;# Test 3&#xA;f(*(1, 2))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;三次调用的输出分别为：&lt;/p&gt;&#xA;&lt;p&gt;Test 1: (1, 2)&#xA;Test 2: ((1, 2),)&#xA;Test 3: (1, 2)&lt;/p&gt;&#xA;&lt;p&gt;Test 1的结果跟{#demo1}一样，此时的x为两个参数构成的元组。Test 2输入参数变成了一个由两个元素构成的元组，此时的x把这个元组当成一个整体作为它的第一个元素，形成了一个新的元组。Test 3在传递参数时，前面添加了*，此时函数f中的x为输入的元组本身，效果与Test 1相同。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
